"""
Cyberpunk Audio Engine (Enhanced)
=================================

This module contains the complete audio system for the Rogue Agent Editor.
It generates MIDI-style melodic sequences and ambient textures.

Themes Available:
- Blade Runner: Bluesy, Vangelis-style melodic sequences
- Cyberpunk 2077: Aggressive, dark industrial sequences
- Alien Isolation: Ethereal, suspenseful textures
- Starlight: Calm ambient pads

Usage:
    from cyberpunk_audio import start_music, stop_music, set_music_volume
    start_music(settings)  # Start playing with settings dict
    stop_music()           # Stop playing
"""

import math
import wave
import tempfile
import os
import threading
import time
import winsound
import atexit
import random
import ctypes
import queue
import struct
import sys

# =====================
# ðŸŽµ AUDIO STATE
# =====================
audio_stop_event = threading.Event()
audio_command_queue = queue.Queue()
current_wav_file = None
audio_threads = []
last_played_file = None

# =====================
# ðŸ“ FILE HANDLING
# =====================

def scan_audio_files():
    """Scan the 'audio' directory for supported files."""
    if getattr(sys, 'frozen', False):
        # Running in a PyInstaller bundle
        if hasattr(sys, '_MEIPASS'):
            base_path = sys._MEIPASS
        else:
            base_path = os.path.dirname(sys.executable)
    else:
        # Running in a normal Python environment
        base_path = os.path.dirname(os.path.abspath(__file__))
        
    audio_dir = os.path.join(base_path, "audio")
    if not os.path.exists(audio_dir):
        try:
            os.makedirs(audio_dir)
        except:
            return []
            
    files = []
    valid_exts = {".wav", ".mp3", ".mid", ".midi"}
    try:
        for f in os.listdir(audio_dir):
            ext = os.path.splitext(f)[1].lower()
            if ext in valid_exts:
                files.append(f)
    except Exception as e:
        print(f"Error scanning audio files: {e}")
    return sorted(files)

def stop_file_playback():
    """Stop all audio playback (Winsound & MCI)."""
    winsound.PlaySound(None, winsound.SND_PURGE)
    try:
        mci = ctypes.windll.winmm.mciSendStringW
        mci("close all", None, 0, 0)
    except:
        pass

def play_file_loop(file_path, volume):
    """Play a file (WAV or MP3) in a loop using MCI."""
    if not os.path.exists(file_path):
        return
        
    ext = os.path.splitext(file_path)[1].lower()
    
    # Stop anything currently playing (Close previous MCI sessions)
    stop_file_playback()
    
    try:
        mci = ctypes.windll.winmm.mciSendStringW
        
        # Determine MCI type
        if ext == ".mp3":
            cmd_type = "type mpegvideo"
        elif ext in [".mid", ".midi"]:
            cmd_type = "type sequencer"
        else:
            cmd_type = "type waveaudio"
            
        # Open the file with alias 'myaudio'
        cmd_open = f'open "{file_path}" {cmd_type} alias myaudio'
        ret = mci(cmd_open, None, 0, 0)
        if ret != 0:
            print(f"MCI Open Error: {ret}")
            return
            
        # Set volume (0-1000)
        vol_int = int(max(0.0, min(1.0, volume)) * 1000)
        mci(f'setaudio myaudio volume to {vol_int}', None, 0, 0)
        
        # Play with repeat
        mci("play myaudio repeat", None, 0, 0)
    except Exception as e:
        print(f"MCI Playback Error: {e}")

def pause_local_audio():
    """Pause the currently playing local file."""
    audio_command_queue.put("pause")

def resume_local_audio():
    """Resume the currently playing local file."""
    audio_command_queue.put("resume")

def set_local_volume(volume):
    """Set volume for local audio (handled via polling in loop)."""
    pass

def stop_local_audio():
    """Stop and rewind the currently playing local file."""
    audio_command_queue.put("stop")

# =====================
# ðŸŽ¹ MUSIC THEORY & CONFIG
# =====================

# Note Frequencies (4th Octave)
NOTES = {
    "C": 261.63, "C#": 277.18, "D": 293.66, "D#": 311.13, "E": 329.63, "F": 349.23,
    "F#": 369.99, "G": 392.00, "G#": 415.30, "A": 440.00, "A#": 466.16, "B": 493.88
}

def get_freq(note, octave_offset=0):
    """Get frequency for a note string (e.g., 'C#') with octave offset."""
    if note not in NOTES: return 0.0
    freq = NOTES[note]
    if octave_offset != 0:
        freq *= (2 ** octave_offset)
    return freq

# Melodic Sequences (Note, Duration, Octave)
# Duration: 1.0 = 1 second
THEMES = {
    "bladerunner": {
        "bpm": 60,
        "style": "melodic",
        "loop": True,
        "sequence": [
            ("E", 2.0, 0), ("G#", 2.0, 0), ("B", 2.0, 0), ("C#", 4.0, 0), # Vangelis-style swelling
            ("A", 2.0, -1), ("C#", 2.0, 0), ("E", 4.0, 0),
            ("F#", 1.0, 0), ("A", 1.0, 0), ("C#", 4.0, 0) 
        ],
        "timbre": "sawtooth_pad" # Rich, warm analog sound
    },
    "cyberpunk_2077": {
        "bpm": 90,
        "style": "aggressive",
        "loop": True,
        "sequence": [
            ("C", 0.5, -1), ("C", 0.5, -1), ("D#", 0.5, -1), ("F", 0.5, -1), # Industrial bassline
            ("C", 0.5, -1), ("G", 0.5, -1), ("F", 0.5, -1), ("D#", 1.0, -1),
            ("C", 0.25, 0), ("D#", 0.25, 0), ("F", 0.5, 0)
        ],
        "timbre": "distorted_square" # Gritty digital sound
    },
    "alien": {
        "bpm": 40,
        "style": "ambient",
        "loop": True,
        "sequence": [
            ("F", 4.0, 1), ("E", 4.0, 1), ("C#", 4.0, 1), # High tension strings
            ("A#", 4.0, 0), ("G", 4.0, 0)
        ],
        "timbre": "sine_vibrato" # Ethereal, unstable
    },
    "starlight": {
        "bpm": 50,
        "style": "ambient",
        "loop": True,
        "sequence": [
            ("C", 4.0, 0), ("E", 4.0, 0), ("G", 4.0, 0), ("B", 4.0, 0), # Major 7th arps
            ("F", 4.0, 0), ("A", 4.0, 0), ("C", 4.0, 1)
        ],
        "timbre": "sine_pad"
    }
}

# =====================
# ðŸŽ›ï¸ AUDIO SYNTHESIS
# =====================

def generate_wave_data(freq, duration, sample_rate, volume, timbre):
    """Generate raw audio data for a single note."""
    n_samples = int(sample_rate * duration)
    data = bytearray()
    
    for i in range(n_samples):
        t = i / sample_rate
        
        val = 0.0
        
        if timbre == "sine_pad":
            # Pure sine with slow attack/release
            osc = math.sin(2 * math.pi * freq * t)
            # Add subtle harmonic
            osc += 0.3 * math.sin(2 * math.pi * (freq * 2.01) * t) 
            val = osc * 0.7
            
        elif timbre == "sine_vibrato":
            # Sine with pitch wobble
            vibrato = 1.0 + 0.005 * math.sin(2 * math.pi * 5 * t)
            osc = math.sin(2 * math.pi * (freq * vibrato) * t)
            val = osc
            
        elif timbre == "sawtooth_pad":
            # Approximated sawtooth for analog feel (additive synthesis)
            osc = 0.0
            for h in range(1, 5):
                osc += (1/h) * math.sin(2 * math.pi * freq * h * t)
            # Add detuned unison
            osc += 0.5 * math.sin(2 * math.pi * (freq * 1.01) * t)
            val = osc * 0.5
            
        elif timbre == "distorted_square":
            # Square wave with clipping
            osc = 1.0 if math.sin(2 * math.pi * freq * t) > 0 else -1.0
            # Add sub-oscillator
            sub = 1.0 if math.sin(2 * math.pi * (freq/2) * t) > 0 else -1.0
            val = (osc + 0.5 * sub) * 0.6
            
        else:
            val = math.sin(2 * math.pi * freq * t)
            
        # Apply envelope (Attack/Release) to prevent clicks
        envelope = 1.0
        attack_time = 0.1
        release_time = 0.1
        
        if i < sample_rate * attack_time:
            envelope = i / (sample_rate * attack_time)
        elif i > n_samples - (sample_rate * release_time):
            remaining = n_samples - i
            envelope = remaining / (sample_rate * release_time)
            
        final_sample = int(32767 * volume * val * envelope)
        final_sample = max(-32767, min(32767, final_sample)) # Clip
        
        data.extend(final_sample.to_bytes(2, byteorder='little', signed=True))
        
    return data

def render_sequence_to_wav(theme_name, volume=0.3):
    """Render a full theme sequence to a single WAV file."""
    try:
        if theme_name not in THEMES:
            return None
            
        theme = THEMES[theme_name]
        sequence = theme["sequence"]
        bpm = theme["bpm"]
        timbre = theme["timbre"]
        
        sample_rate = 22050
        
        fd, path = tempfile.mkstemp(suffix=".wav")
        os.close(fd)
        
        with wave.open(path, 'w') as wav_file:
            wav_file.setnchannels(1)
            wav_file.setsampwidth(2)
            wav_file.setframerate(sample_rate)
            
            # Render each note in sequence
            for note, beats, octave in sequence:
                # Convert beats to seconds (60 / BPM * beats)
                duration = (60.0 / bpm) * beats
                freq = get_freq(note, octave)
                
                # Render note
                note_data = generate_wave_data(freq, duration, sample_rate, volume, timbre)
                wav_file.writeframes(note_data)
                
        return path
        
    except Exception as e:
        print(f"Sequencer error: {e}")
        return None

# =====================
#  AUDIO ENGINE
# =====================

def cyberpunk_music_loop(settings):
    """
    Main audio loop that plays generated sequences or selected files.
    """
    global current_wav_file, last_played_file
    
    # Playlist of themes
    playlist = ["bladerunner", "cyberpunk_2077", "alien", "starlight"]
    playlist_idx = 0
    
    print("ðŸŽµ Cyberpunk Music Engine Started")
    
    while not audio_stop_event.is_set():
        try:
            if settings["audio"]["music_enabled"] and not settings["audio"]["mute_music"]:
                # Check for user selected file
                music_file = settings["audio"].get("music_file", "")
                
                # --- FILE PLAYBACK MODE ---
                if music_file:
                    # Check if it's an absolute path (from file browser) or relative (from audio folder)
                    if os.path.isabs(music_file) and os.path.exists(music_file):
                        full_path = music_file
                    else:
                        full_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "audio", music_file)
                    
                    # If file changed or not playing yet
                    if music_file != last_played_file:
                        play_file_loop(full_path, settings["audio"]["music_volume"])
                        last_played_file = music_file
                        current_wav_file = None # Clear generated file ref
                    
                    # Process Commands (Thread-Safe)
                    # We process commands BEFORE volume updates to ensure we don't accidentally
                    # interact with a paused/stopped stream in a way that might restart it.
                    while not audio_command_queue.empty():
                        cmd = audio_command_queue.get_nowait()
                        try:
                            mci = ctypes.windll.winmm.mciSendStringW
                            if cmd == "pause":
                                mci("pause myaudio", None, 0, 0)
                            elif cmd == "resume":
                                mci("resume myaudio", None, 0, 0)
                            elif cmd == "stop":
                                mci("stop myaudio", None, 0, 0)
                                mci("seek myaudio to start", None, 0, 0)
                        except: pass
                    
                    # Update volume for MCI (WAV & MP3)
                    # Only update volume if we are NOT paused (checking status is expensive, 
                    # but we can infer or just set it. Setting volume on paused stream is usually fine,
                    # but let's be careful not to wake it up).
                    if music_file:
                        try:
                            vol_int = int(settings["audio"]["music_volume"] * 1000)
                            ctypes.windll.winmm.mciSendStringW(f'setaudio myaudio volume to {vol_int}', None, 0, 0)
                        except: pass
                        
                    time.sleep(0.1)
                    continue

                # --- GENERATIVE MODE ---
                # If we were playing a file, stop it
                if last_played_file:
                    stop_file_playback()
                    last_played_file = None
                
                vol = settings["audio"]["music_volume"]
                if vol > 0.01:
                    theme = playlist[playlist_idx]
                    
                    # Generate the full sequence for this theme
                    wav_path = render_sequence_to_wav(theme, volume=vol * 0.7)
                    
                    if wav_path:
                        # Clean old file
                        if current_wav_file and os.path.exists(current_wav_file):
                            try:
                                os.remove(current_wav_file)
                            except:
                                pass
                        current_wav_file = wav_path
                        
                        # Calculate duration of the generated file
                        import contextlib
                        duration = 5.0 # Fallback
                        with contextlib.closing(wave.open(wav_path, 'r')) as f:
                            frames = f.getnframes()
                            rate = f.getframerate()
                            duration = frames / float(rate)
                        
                        print(f"ðŸŽµ Playing Theme: {theme} ({duration:.1f}s)")
                        
                        winsound.PlaySound(current_wav_file, winsound.SND_FILENAME | winsound.SND_ASYNC)
                        
                        # Wait loop with interrupt check
                        waited = 0.0
                        interval = 0.5
                        while waited < duration and not audio_stop_event.is_set():
                            # Check if user switched to file mode
                            if settings["audio"].get("music_file", ""):
                                winsound.PlaySound(None, winsound.SND_PURGE)
                                break
                            
                            time.sleep(interval)
                            waited += interval
                            
                        # Move to next track if we finished naturally
                        if not audio_stop_event.is_set() and not settings["audio"].get("music_file", ""):
                            playlist_idx = (playlist_idx + 1) % len(playlist)
                            
                    else:
                        time.sleep(1)
                else:
                    winsound.PlaySound(None, winsound.SND_PURGE)
                    time.sleep(1)
            else:
                stop_file_playback()
                time.sleep(1)
                
        except Exception as e:
            print(f"Audio playback error: {e}")
            time.sleep(2)

# =====================
# ðŸŽ›ï¸ PUBLIC API
# =====================

def start_music(settings):
    """Start the music engine."""
    global audio_stop_event
    try:
        stop_music() # Ensure clean state
        audio_stop_event.clear()
        t = threading.Thread(target=cyberpunk_music_loop, args=(settings,), daemon=True)
        t.start()
        audio_threads.append(t)
    except Exception as e:
        print(f"Audio system error: {e}")

def stop_music():
    """Stop the music engine."""
    try:
        audio_stop_event.set()
        winsound.PlaySound(None, winsound.SND_PURGE)
        
        # Clean up file
        if current_wav_file and os.path.exists(current_wav_file):
            try:
                os.remove(current_wav_file)
            except:
                pass
    except Exception:
        pass

def set_music_volume(volume):
    pass # Handled in loop

def update_volume_realtime(settings):
    """Force restart not really needed as loop picks it up next track, but implemented for compat."""
    pass 

def cleanup_audio():
    stop_music()

atexit.register(cleanup_audio)

if __name__ == "__main__":
    # Test
    print("Testing Audio Engine...")
    s = {"audio": {"music_enabled": True, "mute_music": False, "music_volume": 0.5}}
    start_music(s)
    time.sleep(20)
    stop_music()
